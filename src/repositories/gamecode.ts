import {getLogger} from '@src/utils/log';
import {getGameConnection, getGameRepository} from '.';
import {GameCodeExternal} from '@src/entity/game/game';
import {getRunProfile, RunProfile} from '@src/server';

const logger = getLogger('repositories::gamecode');

class GameCodeRepositoryImpl {
  private gameCodeSeq = 'game_code_seq';
  private numBuckets = 10;
  private bucketSize = 1000; // 10000 game codes / numBuckets
  private repeat = 10;

  /**
   * Generate all game codes and store them in DB.
   */
  public async initGameCodes() {
    const shouldInit: boolean = await this.shouldInit();
    if (shouldInit) {
      await this.doInit();
    }
    await this.verifyInit();
  }

  private async doInit() {
    await this.initGameCodeSeq();
    const repo = getGameRepository(GameCodeExternal);
    logger.info('Initializing game codes');
    const startTime = performance.now();
    // Generate an array of increasing numbers.
    const allCodes = [...new Array(this.numBuckets * this.bucketSize).keys()];
    // Shuffle the array to randomize the codes.
    this.shuffleArray(allCodes);
    const buckets = new Array<Array<number>>();
    // Split the codes into subarrays.
    for (let i = 0; i < this.numBuckets; i++) {
      const startIdx = i * this.bucketSize;
      const codes: Array<number> = allCodes.slice(
        startIdx,
        startIdx + this.bucketSize
      );
      buckets.push(codes);
    }
    // Insert the subarray into the table.
    // Each row gets one subarray containing a portion of all 10,000 game codes in random order.
    // rowNum column is autogenerated.
    for (let r = 0; r < this.repeat; r++) {
      for (let i = 0; i < this.numBuckets; i++) {
        this.shuffleArray(buckets[i]);
        await repo.insert({codes: buckets[i]});
      }
    }
    const endTime = performance.now();
    const numCodes = this.numBuckets * this.bucketSize;
    logger.info(
      `Initialized ${numCodes} game codes in ${endTime - startTime} ms`
    );
  }

  /**
   * Make sure game codes are initialized before proceeding.
   */
  private async verifyInit() {
    logger.info('Verifying game codes are initialized');
    const startTime = performance.now();
    const query = 'SELECT "rowNum", codes FROM game_code_external';
    const result = await getGameConnection().query(query);
    const totalRows = this.numBuckets * this.repeat;
    if (result.length != totalRows) {
      throw new Error(
        `GameCodeRepositoryImpl.verifyInit result.length = ${result.length}. Expected ${totalRows} rows`
      );
    }
    const lastRowNum = result[result.length - 1].rowNum;
    if (lastRowNum != totalRows) {
      throw new Error(
        `GameCodeRepositoryImpl.verifyInit lastRowNum = ${lastRowNum}. Expected ${totalRows}`
      );
    }
    for (let i = 0; i < result.length; i++) {
      if (result[i].codes.length != this.bucketSize) {
        throw new Error(
          `GameCodeRepositoryImpl.verifyInit row ${result[i].rowNum} codes.length = ${result[i].codes.length}. Expected ${this.bucketSize}`
        );
      }
    }

    if (getRunProfile() != RunProfile.PROD) {
      // Try cycling through all codes.
      const numCodes = (this.numBuckets + 1) * this.bucketSize;
      const buckets = new Array<Array<number>>();
      for (let i = 0; i < this.numBuckets; i++) {
        buckets[i] = new Array<number>();
      }
      for (let i = 0; i < numCodes; i++) {
        const code = await this.getNextGameCode();
        buckets[code % this.numBuckets].push(code);
      }
      for (let i = 0; i < this.numBuckets; i++) {
        const numCodesInBucket = buckets[i].length;
        if (numCodesInBucket < this.bucketSize) {
          throw new Error(
            `GameCodeRepositoryImpl.verifyInit bucket ${i} length = ${numCodesInBucket}. Expected at least ${this.bucketSize}`
          );
        }
      }
    }
    const endTime = performance.now();
    logger.info(`Verified game codes in ${endTime - startTime} ms`);
  }

  /**
   * Read the next game code from the DB.
   */
  public async getNextGameCode(): Promise<number> {
    const totalRows = this.numBuckets * this.repeat;
    const query = `
      WITH cte (gamenum) AS (VALUES(nextval('${this.gameCodeSeq}')))
      SELECT gamenum as "gameNum", gce."rowNum" AS "rowNumUsed", gamenum % ${this.bucketSize} + 1 AS "idxUsed", gce.codes[gamenum % ${this.bucketSize} + 1] AS code
      FROM game_code_external gce, cte
      WHERE gce."rowNum" = ((gamenum / ${this.bucketSize}) % ${totalRows}) + 1;`;
    const result = await getGameConnection().query(query);
    if (result.length === 0) {
      throw new Error(
        `GameCodeRepositoryImpl.getNextGameCode result.length = 0`
      );
    }
    if (result.length != 1) {
      logger.error(
        `getNextGameCode result.length = ${
          result.length
        }. result: ${JSON.stringify(result)}`
      );
      throw new Error(
        `GameCodeRepositoryImpl.getNextGameCode result.length = ${result.length}`
      );
    }
    const row = result[0];
    if (typeof row.code !== 'number') {
      throw new Error(
        `GameCodeRepositoryImpl.getNextGameCode invalid code generated. row: ${JSON.stringify(
          row
        )}`
      );
    }
    return row.code;
  }

  private async initGameCodeSeq() {
    logger.info(`Creating sequence ${this.gameCodeSeq}`);
    await getGameConnection().query(
      `CREATE SEQUENCE IF NOT EXISTS ${this.gameCodeSeq}`
    );
  }

  /**
   * Game codes should only be initialized once across different api server instances and startups.
   * This is the logic to enforce that.
   */
  private async shouldInit(): Promise<boolean> {
    const seqName = 'init_lock';
    await getGameConnection().query(`CREATE SEQUENCE IF NOT EXISTS ${seqName}`);
    const query = `SELECT nextval('${seqName}')::int AS v`;
    const result = await getGameConnection().query(query);
    if (result.length != 1) {
      throw new Error(
        `GameCodeRepositoryImpl.shouldInit result.length = ${result.length}`
      );
    }
    logger.debug(`shouldInit result: ${JSON.stringify(result)}`);
    let res = result[0].v === 1;
    return res;
  }

  private shuffleArray(array: Array<any>) {
    for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
  }
}

export const GameCodeRepository = new GameCodeRepositoryImpl();
